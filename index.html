<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Project 2 — Auto-Save Flow Field</title>

  <!-- iOS fullscreen -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Project 2">

  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <style>
    html, body { margin:0; padding:0; background:#000; height:100%; overflow:hidden; }
    canvas { display:block; }

    /* Buttons */
    #captureBtn, #clearBtn {
      position: fixed; z-index: 10; border: none; cursor: pointer;
    }
    #captureBtn {
      bottom: 30px; left: 50%; transform: translateX(-50%);
      width: 80px; height: 80px; border-radius: 50%;
      background: rgba(255,255,255,0.95); border: 6px solid white;
    }
    #clearBtn {
      top: 20px; right: 20px; width: 44px; height: 44px;
      border-radius: 50%; background: rgba(255,255,255,0.25); border: 2px solid white;
    }

    /* Threshold slider */
    #sliderWrap {
      position: fixed; bottom: 130px; left: 50%; transform: translateX(-50%);
      width: 60%; z-index: 12; text-align: center;
    }
    #thresholdSlider { width: 100%; }

    #badge {
      position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%);
      color: #ddd; font: 14px system-ui, -apple-system, sans-serif;
      background: rgba(0,0,0,0.6); padding: 10px 14px; border-radius: 8px;
      z-index: 11; display: none;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
</head>
<body>
  <button id="clearBtn" aria-label="Clear"></button>
  <button id="captureBtn" aria-label="Capture"></button>
  <div id="sliderWrap">
    <input type="range" min="0" max="100" value="60" id="thresholdSlider">
  </div>
  <div id="badge">Generating…</div>

<script>
/* === Config === */
const SCL = 20, STEP_SPEED = 3, LINE_LEN = 350, LINE_COUNT = 600;
const NOISE_INC = 0.005, Z_INC = 0.001;
const EDGE_STEP = 4;
const PALETTE = [[0,102,255],[255,30,30],[255,220,0]];

/* Globals */
let video, capturedGfx, voidPixels, edgePts = [], lines = [];
let cols, rows, flowfield, zoff = 0;
let hasRender = false;
let thresholdVal = 60;
let badgeEl;

function setup() {
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1);

  video = createCapture({ video: { facingMode: { exact: "environment" } }, audio: false });
  video.hide();

  cols = Math.floor(width / SCL);
  rows = Math.floor(height / SCL);
  flowfield = Array.from({length:cols},()=>Array(rows));

  badgeEl = document.getElementById('badge');

  document.getElementById('thresholdSlider').oninput = e => {
    thresholdVal = e.target.value;
  };

  document.getElementById('captureBtn').onclick = async () => {
    hasRender = false; badgeOn(true);
    await capturePosterized();
    buildVoidMask();
    generateField();
    precomputeLines();
    renderScene();
    badgeOn(false); hasRender = true; noLoop();
    // Auto-save immediately
    saveCanvas('project2_posterized', 'png');
  };

  document.getElementById('clearBtn').onclick = () => {
    hasRender = false; lines = [];
    background(0); loop();
  };

  background(0);
}

function draw() {
  if (hasRender) return;
  if (video.loadedmetadata) drawPosterized(video, width, height, thresholdVal);
}

/* Posterize live video */
function drawPosterized(src, w, h, thresh) {
  src.loadPixels(); loadPixels();
  for (let y=0; y<h; y++) {
    for (let x=0; x<w; x++) {
      let sx = Math.floor(x * src.width / w);
      let sy = Math.floor(y * src.height / h);
      let idx = 4 * (sx + sy * src.width);
      let r=src.pixels[idx], g=src.pixels[idx+1], b=src.pixels[idx+2];
      let lum=(0.299*r+0.587*g+0.114*b)/255*100;
      let v=(lum>thresh)?255:0;
      let di=4*(x+y*w);
      pixels[di]=pixels[di+1]=pixels[di+2]=v; pixels[di+3]=255;
    }
  }
  updatePixels();
}

/* Capture posterized frame */
async function capturePosterized() {
  capturedGfx = createGraphics(width, height);
  video.loadPixels(); capturedGfx.loadPixels();
  for (let y=0; y<height; y++) {
    for (let x=0; x<width; x++) {
      let sx = Math.floor(x * video.width / width);
      let sy = Math.floor(y * video.height / height);
      let idx = 4*(sx+sy*video.width);
      let r=video.pixels[idx], g=video.pixels[idx+1], b=video.pixels[idx+2];
      let lum=(0.299*r+0.587*g+0.114*b)/255*100;
      let v=(lum>thresholdVal)?255:0;
      let di=4*(x+y*width);
      capturedGfx.pixels[di]=capturedGfx.pixels[di+1]=capturedGfx.pixels[di+2]=v;
      capturedGfx.pixels[di+3]=255;
    }
  }
  capturedGfx.updatePixels();
}

/* Void + flow field + lines (same as before) */
function buildVoidMask() {
  voidPixels = new Uint8Array(width*height); edgePts = [];
  capturedGfx.loadPixels();
  for (let y=0;y<height;y++){
    let yIdx=y*width;
    for (let x=0;x<width;x++){
      let i=4*(x+y*width);
      voidPixels[yIdx+x]=(capturedGfx.pixels[i]===255)?1:0;
    }
  }
  for (let y=1;y<height-1;y+=EDGE_STEP){
    let yIdx=y*width;
    for (let x=1;x<width-1;x+=EDGE_STEP){
      if(voidPixels[yIdx+x]===1){
        let boundary=false;
        for (let dy=-1;dy<=1&&!boundary;dy++){
          for (let dx=-1;dx<=1;dx++){
            if(voidPixels[(y+dy)*width+(x+dx)]===0){boundary=true;break;}
          }
        }
        if(boundary) edgePts.push(createVector(x,y));
      }
    }
  }
}

function generateField(){
  let yoff=0;
  for(let y=0;y<rows;y++){
    let xoff=0;
    for(let x=0;x<cols;x++){
      let angle=noise(xoff,yoff,zoff)*TWO_PI*2;
      flowfield[x][y]=p5.Vector.fromAngle(angle).setMag(1);
      xoff+=NOISE_INC;
    }
    yoff+=NOISE_INC;
  }
  zoff+=Z_INC;
}

function spawnOutside(){let p;do{p=createVector(random(width),random(height));}while(voidPixels[Math.floor(p.y)*width+Math.floor(p.x)]===1);return p;}
function spawnBorder(){const side=int(random(4));let p;if(side===0)p=createVector(random(width),5);else if(side===1)p=createVector(random(width),height-5);else if(side===2)p=createVector(5,random(height));else p=createVector(width-5,random(height));if(voidPixels[Math.floor(p.y)*width+Math.floor(p.x)]===1)return spawnOutside();return p;}
function spawnNearEdge(){if(edgePts.length===0)return spawnOutside();for(let tries=0;tries<200;tries++){let e=edgePts[int(random(edgePts.length))];let dir=p5.Vector.random2D();let r=random(8,120);let p=p5.Vector.add(e,p5.Vector.mult(dir,r));if(p.x>=0&&p.x<width&&p.y>=0&&p.y<height&&voidPixels[Math.floor(p.y)*width+Math.floor(p.x)]===0)return p;}return spawnOutside();}

class FlowLine{
  constructor(mode){if(mode==="nearVoid")this.pos=spawnNearEdge();else if(mode==="border")this.pos=spawnBorder();else this.pos=spawnOutside();const c=PALETTE[int(random(PALETTE.length))];this.col=color(...c);this.sw=(random(1)<0.7)?random(1,3):random(4,7);this.pts=[];}
  stepOnce(){if(this.pts.length>=LINE_LEN)return false;let gx=int(constrain(this.pos.x/SCL,0,cols-1));let gy=int(constrain(this.pos.y/SCL,0,rows-1));let f=flowfield[gx][gy].copy().mult(STEP_SPEED);let next=p5.Vector.add(this.pos,f);if(next.x<0||next.x>=width||next.y<0||next.y>=height)return false;if(voidPixels[Math.floor(next.y)*width+Math.floor(next.x)]===1)return false;this.pos=next;this.pts.push(this.pos.copy());return true;}
  complete(){let guard=0;while(this.pts.length<LINE_LEN&&guard<LINE_LEN*2){if(!this.stepOnce())break;guard++;}}
  drawShape(){if(this.pts.length<2)return;noFill();stroke(this.col);strokeWeight(this.sw);beginShape();for(const p of this.pts)vertex(p.x,p.y);endShape();}
}

function precomputeLines(){lines=[];let n=int(LINE_COUNT*0.5),b=int(LINE_COUNT*0.2),f=LINE_COUNT-n-b;for(let i=0;i<n;i++){let L=new FlowLine("nearVoid");L.complete();lines.push(L);}for(let i=0;i<b;i++){let L=new FlowLine("border");L.complete();lines.push(L);}for(let i=0;i<f;i++){let L=new FlowLine("outside");L.complete();lines.push(L);}}
function renderScene(){background(0);for(const L of lines)L.drawShape();}
function badgeOn(on){badgeEl.style.display=on?"block":"none";}
</script>
</body>
</html>
