<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Project 2 — Flow Field (Camera Void)</title>

  <!-- iOS app-like fullscreen -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Project 2">

  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <style>
    html, body { margin:0; padding:0; background:#000; height:100%; overflow:hidden; }
    canvas { display:block; }

    /* iPhone-style UI */
    #captureBtn, #clearBtn, #saveBtn {
      position: fixed; z-index: 10; border: none; cursor: pointer;
    }
    #captureBtn {
      bottom: 30px; left: 50%; transform: translateX(-50%);
      width: 80px; height: 80px; border-radius: 50%;
      background: rgba(255,255,255,0.95); border: 6px solid white;
    }
    #clearBtn {
      top: 20px; right: 20px; width: 44px; height: 44px;
      border-radius: 50%; background: rgba(255,255,255,0.25); border: 2px solid white;
    }
    #saveBtn {
      top: 20px; left: 20px; width: 44px; height: 44px;
      border-radius: 50%; background: rgba(0,200,0,0.35); border: 2px solid #9cff9c;
    }

    /* tiny “generating” badge when precomputing */
    #badge {
      position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%);
      color: #ddd; font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: rgba(0,0,0,0.6); padding: 10px 14px; border-radius: 8px;
      z-index: 11; display: none;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
</head>
<body>
  <button id="saveBtn" aria-label="Save"></button>
  <button id="clearBtn" aria-label="Clear"></button>
  <button id="captureBtn" aria-label="Capture"></button>
  <div id="badge">Generating…</div>

<script>
/* ======= Project 2 (camera-based void) ======= */
/* Tunables (kept reasonable for iPhone; you can raise on desktop) */
const SCL         = 20;     // flow field cell size
const STEP_SPEED  = 3;      // step size per vertex
const LINE_LEN    = 350;    // vertices per line (Processing: 1000)
const LINE_COUNT  = 600;    // number of lines (Processing: 2500)
const NOISE_INC   = 0.005;  // smoother field like Processing
const Z_INC       = 0.001;  // slow evolution (single render anyway)
const EDGE_STEP   = 4;      // edge sampling stride (larger = faster)
const THRESH_B    = 70;     // brightness threshold (0..100); >THRESH = VOID (bright)

/* Colors (Processing palette) */
const PALETTE = [
  [  0,102,255],  // blue
  [255, 30, 30],  // red
  [255,220,  0]   // yellow
];

/* Globals */
let video;
let flowfield; // 2D array of vectors
let cols, rows;
let zoff = 0;

let capturedGfx = null;   // captured camera frame at canvas size
let voidPixels = null;    // boolean mask (Uint8Array) length width*height
let edgePts = [];         // boundary points of the void
let lines = [];           // FlowLine instances

let generating = false;
let hasRender = false;

/* UI handles */
let captureBtn, clearBtn, saveBtn, badgeEl;

function setup() {
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1);

  // Rear camera, no distortion (we'll draw with aspect-correct cropping)
  video = createCapture({ video: { facingMode: { exact: "environment" } }, audio: false });
  video.hide();

  cols = Math.floor(width / SCL);
  rows = Math.floor(height / SCL);
  flowfield = new Array(cols);
  for (let x = 0; x < cols; x++) flowfield[x] = new Array(rows);

  captureBtn = document.getElementById('captureBtn');
  clearBtn   = document.getElementById('clearBtn');
  saveBtn    = document.getElementById('saveBtn');
  badgeEl    = document.getElementById('badge');

  captureBtn.addEventListener('click', async () => {
    if (!video || !video.loadedmetadata) return;
    hasRender = false;
    badgeOn(true);
    await captureFrameAspectFit();   // -> capturedGfx (canvas-sized)
    buildVoidMask();                 // -> voidPixels + edgePts
    generateField();                 // -> flowfield
    precomputeLines();               // -> lines
    renderScene();                   // draw once
    badgeOn(false);
    hasRender = true;
    noLoop();                        // static, like Processing
  });

  clearBtn.addEventListener('click', () => {
    hasRender = false;
    lines = [];
    background(0);
    loop(); // back to live preview
  });

  saveBtn.addEventListener('click', () => {
    saveCanvas('project2_flowfield', 'png'); // iOS: tap, then “Save Image”
  });

  background(0);
}

function draw() {
  if (hasRender) return; // static after render
  if (video && video.loadedmetadata) drawVideoAspectFit(video);
}

/* ======= Camera helpers (no distortion, fill canvas) ======= */
function drawVideoAspectFit(src) {
  const vidW = src.width, vidH = src.height;
  const vidAspect = vidW / vidH;
  const canvasAspect = width / height;

  if (vidAspect > canvasAspect) {
    // Video wider → crop sides
    const newW = vidH * canvasAspect;
    const sx = (vidW - newW) / 2;
    image(src, 0, 0, width, height, sx, 0, newW, vidH);
  } else {
    // Video taller → crop top/bottom
    const newH = vidW / canvasAspect;
    const sy = (vidH - newH) / 2;
    image(src, 0, 0, width, height, 0, sy, vidW, newH);
  }
}

async function captureFrameAspectFit() {
  // Draw the aspect-correct preview into an offscreen graphics at canvas size
  capturedGfx = createGraphics(width, height);
  const src = video;
  const vidW = src.width, vidH = src.height;
  const vidAspect = vidW / vidH;
  const canvasAspect = width / height;

  if (vidAspect > canvasAspect) {
    const newW = vidH * canvasAspect;
    const sx = (vidW - newW) / 2;
    capturedGfx.image(src, 0, 0, width, height, sx, 0, newW, vidH);
  } else {
    const newH = vidW / canvasAspect;
    const sy = (vidH - newH) / 2;
    capturedGfx.image(src, 0, 0, width, height, 0, sy, vidW, newH);
  }
  // ensure pixels buffered for sampling
  capturedGfx.loadPixels();
}

/* ======= Brightness helpers ======= */
function brightnessAt(x, y) {
  // x,y in canvas space; capturedGfx is canvas-sized
  const ix = Math.floor(constrain(x, 0, width - 1));
  const iy = Math.floor(constrain(y, 0, height - 1));
  const idx = 4 * (ix + iy * width);
  const p = capturedGfx.pixels;
  const r = p[idx], g = p[idx + 1], b = p[idx + 2];
  // perceptual luminance -> 0..100
  const lum = (0.299 * r + 0.587 * g + 0.114 * b) / 255 * 100;
  return lum;
}

/* Build void mask (bright = void) and collect boundary points */
function buildVoidMask() {
  voidPixels = new Uint8Array(width * height);
  edgePts = [];

  // mark void
  for (let y = 0; y < height; y += 1) {
    const yIdx = y * width;
    for (let x = 0; x < width; x += 1) {
      const b = brightnessAt(x, y);
      voidPixels[yIdx + x] = (b > THRESH_B) ? 1 : 0; // 1 = VOID (bright)
    }
  }

  // collect edges: void pixel with any neighbor non-void
  for (let y = 1; y < height - 1; y += EDGE_STEP) {
    const yIdx = y * width;
    for (let x = 1; x < width - 1; x += EDGE_STEP) {
      const here = voidPixels[yIdx + x];
      if (here === 1) {
        let boundary = false;
        for (let dy = -1; dy <= 1 && !boundary; dy++) {
          const ny = y + dy;
          const nIdx = ny * width;
          for (let dx = -1; dx <= 1; dx++) {
            if (voidPixels[nIdx + (x + dx)] === 0) { boundary = true; break; }
          }
        }
        if (boundary) edgePts.push(createVector(x, y));
      }
    }
  }
}

/* ======= Flow field (smooth, like Processing) ======= */
function generateField() {
  let yoff = 0;
  for (let y = 0; y < rows; y++) {
    let xoff = 0;
    for (let x = 0; x < cols; x++) {
      const angle = noise(xoff, yoff, zoff) * TWO_PI * 2.0;
      const v = p5.Vector.fromAngle(angle);
      v.setMag(1);
      flowfield[x][y] = v;
      xoff += NOISE_INC;
    }
    yoff += NOISE_INC;
  }
  zoff += Z_INC;
}

/* ======= Spawn helpers (near void edge, at border, or anywhere outside void) ======= */
function isInVoid(x, y) {
  const ix = Math.floor(constrain(x, 0, width - 1));
  const iy = Math.floor(constrain(y, 0, height - 1));
  return voidPixels[iy * width + ix] === 1;
}

function outwardFromEdge(e) {
  const samples = 16;
  for (let k = 0; k < samples; k++) {
    const ang = TWO_PI * k / samples;
    const sx = e.x + Math.cos(ang) * 6;
    const sy = e.y + Math.sin(ang) * 6;
    if (sx >= 0 && sx < width && sy >= 0 && sy < height) {
      if (!isInVoid(sx, sy)) {
        return createVector(Math.cos(ang), Math.sin(ang));
      }
    }
  }
  return p5.Vector.random2D();
}

function spawnNearEdge() {
  if (edgePts.length === 0) return spawnOutside();
  for (let tries = 0; tries < 200; tries++) {
    const e = edgePts[(Math.random() * edgePts.length) | 0];
    const dir = outwardFromEdge(e);
    const r = random(8, 120);
    const p = p5.Vector.add(e, p5.Vector.mult(dir, r));
    if (p.x >= 0 && p.x < width && p.y >= 0 && p.y < height && !isInVoid(p.x, p.y)) {
      return p;
    }
  }
  return spawnOutside();
}

function spawnOutside() {
  let p;
  do {
    p = createVector(random(width), random(height));
  } while (isInVoid(p.x, p.y));
  return p;
}

function spawnBorder() {
  const side = (Math.random() * 4) | 0;
  let p;
  if (side === 0) p = createVector(random(width), 5);               // top
  else if (side === 1) p = createVector(random(width), height - 5); // bottom
  else if (side === 2) p = createVector(5, random(height));         // left
  else p = createVector(width - 5, random(height));                 // right
  if (isInVoid(p.x, p.y)) return spawnOutside();
  return p;
}

/* ======= FlowLine ======= */
class FlowLine {
  constructor(mode) {
    if (mode === "nearVoid")      this.pos = spawnNearEdge();
    else if (mode === "border")   this.pos = spawnBorder();
    else                          this.pos = spawnOutside();

    // color from palette
    const c = PALETTE[(Math.random() * PALETTE.length) | 0];
    this.col = color(c[0], c[1], c[2]);

    // biased stroke weight: mostly thin, some thick
    if (Math.random() < 0.7) this.sw = random(1, 3);   // 70% thin
    else                     this.sw = random(4, 7);   // 30% thick

    this.pts = [];
  }

  stepOnce() {
    if (this.pts.length >= LINE_LEN) return false;
    const gx = Math.floor(constrain(this.pos.x / SCL, 0, cols - 1));
    const gy = Math.floor(constrain(this.pos.y / SCL, 0, rows - 1));
    const f = flowfield[gx][gy].copy().mult(STEP_SPEED);

    const next = p5.Vector.add(this.pos, f);
    if (next.x < 0 || next.x >= width || next.y < 0 || next.y >= height) return false;
    if (isInVoid(next.x, next.y)) return false;

    this.pos = next;
    this.pts.push(this.pos.copy());
    return true;
  }

  complete() {
    let guard = 0;
    while (this.pts.length < LINE_LEN && guard < LINE_LEN * 2) {
      if (!this.stepOnce()) break;
      guard++;
    }
  }

  drawShape() {
    if (this.pts.length < 2) return;
    noFill();
    stroke(this.col);
    strokeWeight(this.sw);
    beginShape();
    for (const p of this.pts) vertex(p.x, p.y);
    endShape();
  }
}

/* ======= Precompute & Render ======= */
function precomputeLines() {
  lines = [];
  const nearQuota   = Math.floor(LINE_COUNT * 0.5);
  const borderQuota = Math.floor(LINE_COUNT * 0.2);
  const farQuota    = LINE_COUNT - nearQuota - borderQuota;

  for (let i = 0; i < nearQuota; i++) {
    const L = new FlowLine("nearVoid"); L.complete(); lines.push(L);
  }
  for (let i = 0; i < borderQuota; i++) {
    const L = new FlowLine("border");   L.complete(); lines.push(L);
  }
  for (let i = 0; i < farQuota; i++) {
    const L = new FlowLine("outside");  L.complete(); lines.push(L);
  }
}

function renderScene() {
  background(0);
  for (const L of lines) L.drawShape();
}

/* ======= Small badge ======= */
function badgeOn(on) {
  badgeEl.style.display = on ? 'block' : 'none';
}
</script>
</body>
</html>
